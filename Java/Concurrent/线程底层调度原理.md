[TOC]

# 操作系统进程
>Book：[操作系统](https://chyyuu.gitbooks.io/ucorebook/content/zh/chapter-4/process_schedule_principal.html)

## 进程调度时机

- 进程执行完毕
- 进程被阻塞（I/O调用，同步互斥）
- 进程主动放弃CPU调用，回到就绪态
- 阻塞态的进程获得了资源，回到就绪态
- 执行中的线程时间片已到，回到就绪态
- 执行完系统调用后返回用户当前时，可选择其他用户进程执行
- 就绪队列中的进程优先级高于当前正在执行的进程的优先级

## 进程调度方式

- 可抢占式：高优先级的进程会立即进行调度，完成进程切换
- 不可抢占式：即使优先级高也不会进行调度

## 进程调度算法

- 先来先服务（FCFS）：不可抢占式
- 短作业优先（SJF）：可抢占式和不可抢占式皆可
- 时间片轮转（RR）：一般时间片为1-100ms之间
- 高响应比优先（HRRF）：Rp=（等待时间+预计执行时间）/执行时间 = 响应时间/执行时间
- 多级反馈队列（Multi-Level Feedback Queue）
- 最高优先级优先

# 多线程实现原理概述
多线程之所以能够实现，第一是硬件的功劳，也就是CPU。现代的CPU有一个很重要的特性，就是时间片。每一段获得CPU的代码只能运行一个时间片规定的时间，例如10ms。到时间之后CPU就会把正在运行的代码暂停，然后发生一个中断。这个中断是系统级的事件，只有操作系统能够接手，这样控制权就落到了操作系统手里。

接下来就是操作系统的事情了。线程对操作系统来说就是一段代码+运行时数据（主要是寄存器数据，还有线程中与资源相关的数据，比如打开的文件等）。操作系统会为每个线程保存相关的这些数据，当接收到来自CPU的时间片中断事件时，就会按一定规则从这些线程中选择一个，恢复它的运行时数据，这样CPU就可以继续执行这个线程了。

选择一个合适的线程的过程称为线程调度，最简单的规则是FCFS(先来先服务)，也就是按排队的时间先后顺序调度，谁先来排队，下一个就让谁运行。另外还有按优先级、按任务大小等调度策略，以及多种策略的组合等方式。

Java中线程实现主要依赖于操作系统，其本身不进行线程管理。它只是把线程相关的操作进行了封装和抽象，以方便我们使用。例如，Java中的线程可以设置优先级，但如果操作系统本身不支持优先级调度策略，那么为线程设置优先级是没有任何作用的。

调度策略：
1. 抢占式调度策略
2. 时间片轮转调度策略

# Java 线程与操作系统线程
从上我们知道，Java 线程是建立在系统本地线程之上的，是另一层封装，其面向 Java 开发者提供的接口存在以下的局限性：
1. 线程返回值
  Java 没有提供方法来获取线程的退出返回值。实际上，线程可以有退出返回值，它一般被操作系统存储在线程控制结构中 （TCB），调用者可以通过检测该值来确定线程是正常退出还是异常终止。
2. 线程的同步
  Java 提供方法 Thread#Join（）来等待一个线程结束，一般情况这就足够了，但一种可能的情况是，需要等待在多个线程上（比如任意一个线程结束或者所有线程结束才会返回），循环调用每个线程的 Join 方法是不可行的，这可能导致很奇怪的同步问题。
3. 线程的 ID
  Java 提供的方法 Thread#getID（）返回的是一个简单的计数 ID，其实和操作系统线程的 ID 没有任何关系。
4. 线程运行时间统计
  Java 没有提供方法来获取线程中某段代码的运行时间的统计结果。虽然可以自行使用计时的方法来实现（获取运行开始和结束的时间，然后相减 ），但由于存在多线程调度方法的原因，无法获取线程实际使用的 CPU 运算时间，因而必然是不准确的。