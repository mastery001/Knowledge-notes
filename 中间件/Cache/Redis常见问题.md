# 缓存一致性

主要是Cache和DB的数据会出现不一致；一般针对缓存的读写（Cache Aside Pattern）是：

- 读流程：
  - 先读Cache，如果命中则返回
  - 未命中时读DB，并将新数据写入到Cache
- 写流程：
  - 先写DB
  - 再淘汰Cache



缓存的更新方式：

1. 先更新Cache，再更新数据库：如果更新数据库失败就打不到持久化的目的
2. 先更新数据库，再更新Cache：容易出现ABA问题；A和B先后更新，但最终Cache里却是A，而不是预期的B
3. 先淘汰Cache，再更新数据库：会出现以下两种情况
   1. 读写时序不一致：写请求把Cache淘汰，此时读请求去读Cache读不到就去读DB；写请求还没更新DB，读请求读取到的就是老数据并写入Cache，而此时写请求成功；从而导致缓存和db不一致
   2. 主从延迟不一致：写请求成功到主库，但此时从库还没接受到主库同步，读请求读到的还是从库的老数据
4. 先更新数据库，再淘汰Cache：
   1. 可能不一致的情况
      1. 读请求Cache失效，查数据库得到旧值；写请求更新数据库，并淘汰缓存；读请求将旧值写入Cache：成立的前提是读取数据的时候Cache刚好失效并且还伴随着新的写入，一般读远远大于写，这种情况很难碰到
      2. 【主从延迟】写请求淘汰Cache后，由于主从同步，读请求读到的还是从库未同步主库的值，导致不一致
   2. 淘汰Cache失败的情况：
      1. 同步重试：有可能是网络情况，重试也是失败的，一般会等待一段时候后再重试
      2. 异步重试：起一个线程去重试，但是在机器宕机的情况下也有可能会丢失这个操作
      3. 队列重试：由于一般不会出现DB和队列都不可用，所以这种可以保证两个情况都执行
   3. 主从延迟的情况：订阅binlog来将旧值删除
5. 如何强一致：2PC或3PC、分布式读写锁



[数据库与缓存数据一致性问题](https://blog.xieyangzhe.com/archives/864)

# 缓存四大问题


1. 缓存穿透：大量请求一条不存在或异常的数据
    1. set空值
    2. BloomFilter
2. 缓存击穿：某个key突然失效来了大量请求
    1. 互斥锁请求
3. 缓存雪崩：大规模缓存失效，导致流量全部都到DB
    1. 事前：集群 + redis缓存使用不同时间
    2. 事中：本地缓存+熔断限流
    3. 事后：redis持久化
4. 热key：超出redis处理能力的一些key，例如redis可承载20W的qps，但实际来了100W的qps，就会导致后续的请求超时、阻塞住
    1. 二级缓存：每次都在本地缓存一份
    2. 自动探测+二级缓存：识别热key并缓存到本地、通知到其他机器
    3. 针对刷子用户--日常识别添加到本地缓存



